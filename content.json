{"meta":{"title":"Erbai","subtitle":"","description":"","author":"Erbai","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"promise","slug":"promise","date":"2020-04-06T08:29:10.042Z","updated":"2020-04-06T08:29:21.130Z","comments":true,"path":"2020/04/06/promise/","link":"","permalink":"http://yoursite.com/2020/04/06/promise/","excerpt":"Promise的使用","text":"Promise的使用 promise出现的原因在实际的使用中，有非常多的应用场景我们不能立即知道应该如何继续往下执行，最常见的一个场景就是ajax请求。 在ajax的原生视线中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到想要的数据，之后才能开始处理数据。 这样看上去并没有什么麻烦，但如果这个时候，我们还需要另外一个ajax请求，这个新ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候就需要等上一个接口请求完成之后，再请求后一个接口。 当出现第三个ajax任然依赖上一个请求时，我们的代码就变成了一场灾难，往往也被称为回调地狱 因此，promise可以解决这个问题。还有一个非常重要的需求：为了代码更加具有可读性和可维护性，我们需要将数据请求与数据处理明确的区分开来。 promise基础知识Promise本质上是一个函数返回的对象，我们可以在它上面绑定回调函数。 Promise对象有三种状态 peending：等待中，或者进行中，表示还没有结果 resolved：已经完成，表示得到了我们想要的结果，可以继续往下执行（接收成功回调） rejected：也表示得到结果，但是由于结果并非我们所愿的，因此拒绝执行（接收失败回调） Promise的then方法可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。 12345678910111213141516function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;).then(function() &#123; console.log('参数是一个number值'); &#125;, function() &#123; console.log('参数不是一个number值'); &#125;)&#125;fn('hahha');fn(1234); then方法的执行结果也会返回一个pormise对象，因此我们可以进行then的链式编程，这也是解决回调地狱的主要方式。 123456789101112131415161718function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;) .then(function() &#123; console.log('参数是一个number值'); &#125;) .then(null, function() &#123; console.log('参数不是一个number值'); &#125;)&#125;fn('hahha');fn(1234);","categories":[],"tags":[]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2020-04-06T08:24:15.558Z","updated":"2020-04-06T08:28:59.944Z","comments":true,"path":"2020/04/06/Vue生命周期/","link":"","permalink":"http://yoursite.com/2020/04/06/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Vue生命周期","text":"Vue生命周期 beforeCreate作用：组件实例刚被创建，组件属性计算之前，如data属性等 例如，可以在这加个loading事件 created作用：组件实例创建完成，属性已经绑定，但DOM还未生产，$el属性还不存在 例如，在这结束loading，还做一些初始化，实现函数自执行 beforeMount作用：模板编译/挂载之前 mounted作用：模板编译/挂载之后（不保证组件已经在document中） 例如，在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeUpdate作用：组件更新之前 Updated作用：组件更新之后 beforeDestory作用：组件销毁前调用 例如，你确认删除xx吗？ destoryed作用：组件销毁后调用 例如，当前组件已被删除，清空相关内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; message : \"xuxiao is boy\" &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); &#125;, destroyed: function () &#123; console.group('destroyed 销毁完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; created和mounted相关beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成挂载","categories":[],"tags":[]},{"title":"Vue基础","slug":"Vue基础","date":"2020-03-14T02:38:51.067Z","updated":"2020-03-14T03:41:39.878Z","comments":true,"path":"2020/03/14/Vue基础/","link":"","permalink":"http://yoursite.com/2020/03/14/Vue%E5%9F%BA%E7%A1%80/","excerpt":"Vue基础","text":"Vue基础 vue是什么 Vue是一个优秀的前端框架 市场占比 非常大 绝大多数公司（中小型）都用vue开发PC、移动端 vue的特点 响应式数据 数据驱动视图 =》数据变化 则视图一定变化 MVVM双向绑定=》 数据变化 视图变化（响应式数据）=》视图变化 则数据变化 指令增强了html功能 一个指令对应一种功能 组件化开发=》SPA=》只有一个页面 复用代码 =》重复的事情不做第二次=》抽提封装 一些链接Vue官方文档 Vue开源项目汇总 Vue.js中文社区 安装方式 采用本地文件引入的方式 直接下载vuejs在页面中引入 采用 在线cdn引入的方式 cdn相当于把一个文件放在了全国各地,然后你离哪里近,就从哪里调拨给你 用更快的方式获取到文件资源 npm安装 npm install vue 实例选项el 当前Vue实例所管理的html视图 通常是id选择器 不要让el所管理的视图是html或者body data 响应式 数据对象 Vue实例vm也代理了data对象中的所有的属性 vm.a等价于vm.$data.a 数据对象的更新方式直接 采用 实例.属性=值 methods key(方法名)：value(function) 方法中的this 自动绑定为Vue实例vm 注意*：不应该使用箭头函数来定义methods函数 理由是箭头函数绑定了父级作用域的上下文，this将不会按照期望指向Vue实例，this.a将是undefined 123456789101112131415161718var vm = new Vue(&#123;el:\"#app\",data:&#123;name:\"Hello world\",name2:\"Hello world2\"&#125;,methods:&#123;fn1:function()&#125;// 常规写法console.log(this.name)this.fn2() // 调用方法2&#125;,fn2() &#123;// es6 写法console.log(this.name2)&#125;&#125;&#125;) 插值表达式 作用：会将绑定的数据实时的显示出来=》响应式数据 形式：通过双大括号包裹的形式 注意：不能写var a =10；分支语句 循环语句 指令 一个指令，一个功能 带有v-前缀的特殊特性 v-指令=&quot; &#39;字符串&#39; &quot;，否则会被当做一个 data数据中的变量 v-text和v-html v-text：更新标签中的内容 v-text和插值表达式的区别 v-text 更新 整个标签中的内容 插值表达式：更新标签中局部的内容 v-html：更新标签中的内容/标签 渲染内容中的HTML标签 注意：尽量避免使用，容易造成危险(xss跨站脚本攻击) v-if和v-show 场景：需要根据条件决定 元素是否显示 使用：v-if和v-show后面的表达式返回的是 布尔值 来决定该元素的显示隐藏 区别： v-if 是直接决定元素的添加 或者删除 v-show 只是根据样式来决定 显示还是隐藏 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;!-- 如果isShow的值是true ,就显示p标签 --&gt; &lt;p v-if=\"isShow\"&gt;我是p标签中的内容&lt;/p&gt; &lt;p v-show=\"isShow\"&gt;我是p标签中的内容&lt;/p&gt; &lt;!-- 如果标签显示与隐藏切换频繁, 就使用v-show v-show本质是通过修改标签的display值 --&gt;&lt;/div&gt;&lt;script src=\"./vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; isShow: false &#125; &#125;);&lt;/script&gt; template不会产生任何实质的标签在页面上，并且能完成相应的功能 v-on绑定事件 使用：绑定v-on：事件名.修饰符=“方法名”可使用@事件名=“方法名”的方式 注意：方法名中可以采用$event的方式传参 也可以直接写方法名 默认第一个参数为event事件参数 修饰符（可不写） .once 只触发一次回调 .prevent 调用event.preventDefault()-阻止默认行为 1&lt;button @click.once=\"fn4\"&gt;只执行一次&lt;/button&gt; v-for-数组 v-for指令需要使用item in list或者 item of list 形式的特殊语法 items源数据数组/对象–数组中的每一项 index为数组的索引 ：key 唯一标识—用v-for就要写 v-for-对象 v-for=“（value，key，index）in obj” value值 key键 index下标 v-if和v-for优先级 v-for的优先级大于v-if v-for-key 场景：列表数据变动会导致 视图列表重新更新 为了提升性能 方便更新 需要提供一个属性key 使用：通常是给列表数据中的唯一值 也可以用索引值 123&lt;ul&gt; &lt;li v-for=\"(item,index) in list\" :key=\"index\"&gt;&#123;&#123;item&#125;&#125;---&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt; v-bind 绑定属性 作用：绑定标签上的任何属性 场景：当标签上的属性时 变量|动态|需要改变的 1234&lt;p v-bind:id=\"ID\"&gt;&lt;/p&gt; // ID为数据对象中的变量值or&lt;p :id=\"ID\"&gt;&lt;/p&gt; // 简写&lt;p :class=\"Class\"&gt;&lt;/p&gt; // class的字符串语法 v-model 双向绑定 作用：表单元素的绑定 input/checkbox/textarea 特点：双向数据绑定 语法糖原理：v-bind和v-on组合实现 1234567891011121314151617181920&lt;div id=\"app\"&gt;&lt;input type=\"text\" @input=\"changeInput\" :value=\"name\" /&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;script src=\"./vue.js\"&gt;&lt;/script&gt;&lt;script&gt;var vm = new Vue(&#123;el: \"#app\",data: &#123;name: \"张三\"&#125;,methods: &#123;changeInput(event) &#123;// 值发生改变时 会触发这个方法// 去value值this.name = event.target.value;&#125;&#125;&#125;);&lt;/script&gt; v-cloak 解决页面闪烁 解决页面初次渲染时 页面模板闪屏现象 12345678&lt;div v-cloak id=\"app\"&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123[v-cloak] &#123; display: none;&#125; v-once 只渲染一次页面视图 千万不能作用在 顶级的div上 =&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; ref操作DOM 作用：通过ref特性可以获取元素的dom对象 使用：给元素定义 ref属性, 然后通过$refs.名称 来获取dom对象 1&lt;input type=\"text\" ref=\"myInput\" /&gt; // 定义ref 123focus() &#123; this.$refs.myInput.focus();&#125; // 获取dom对象 聚焦 自定义指令 使用场景：需要对普通DOM元素进行操作，这时候就会用到自定义指令 分类：全局注册和局部注册 全局自定义指令 在创建 Vue 实例之前定义全局自定义指令Vue.directive() Vue.directive(‘指令的名称’,{ inserted: (使用指令的DOM对象) =&gt; { 具体的DOM操作 } } ); 在视图中通过”v-自定义指令名”去使用指令 123456789 // 定义指令// 自定义指令是不需要加v-前缀的// 第二个参数为一个对象 对象中要实现 inserted的方法// inserted中的参数为当前指令所在元素的dom对象Vue.directive(\"focus\", &#123; inserted(dom) &#123; dom.focus(); &#125; &#125;); 局部自定义指令1234567directives: &#123;focus: &#123; inserted(dom) &#123; dom.focus(); &#125;&#125;&#125; // 局部自定义指令实现 计算属性-computed 场景：当插值表达式过于复杂的情况下 可以采用计算属性 对于任何复杂逻辑都可以采用计算属性 说明：计算属性的值 依赖 数据对象中的值 数据对象发生改变=》计算属性也发生改变=》视图改变 计算属性必须有返回值相当于对插值表达式逻辑的一次封装 方法和计算属性的区别 计算属性执行完一次之后，会将执行的结果缓存，如果计算属性依赖的数据没有发生变化，那么，计算属性会从缓存中取，如果发生变化，会重新计算并缓存 总结：计算属性的效率更高，有缓存机制，优于方法 12345678computed: &#123;nameReverse() &#123;return this.name.split(\"\").reverse().join(\"\");&#125;&#125; // 定义计算属性 watch-监听数据 场景： 当需要根据数据(data)变化 进行相应业务操作,且该操作是异步操作时,计算属性不能再使用,可以使用监听watch特性 watch是专门 来监听 data中的数据变化的一个选项 监控谁就写谁的名字key(监控名称):value(函数=&gt;当data值发生改变时就会执行) 函数有两个参数 newValue(新值) oldValue(旧值) 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; city &#125;&#125;&lt;/p&gt; &lt;input type=\"text\" v-model=\"city\"&gt; &lt;ul&gt; &lt;li v-for=\"item in list\"&gt; &lt;span v-text=\"'城市:'+item.name\"&gt;&lt;/span&gt; &lt;span v-text=\"'薪水:'+item.money\"&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"./vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; city: '北京', list: [ &#123; name: \"北京\", money: 10000 &#125;, &#123; name: \"北京\", money: 20000 &#125;, &#123; name: \"北京\", money: 30000 &#125;] &#125;, methods: &#123;&#125;, watch: &#123; city: function (newValue) &#123; // this指向vm this.list = this.list.map(function (item) &#123; item.name = newValue return item &#125;) &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"Git教程","slug":"Git教程","date":"2020-03-12T04:53:54.085Z","updated":"2020-03-12T07:08:53.867Z","comments":true,"path":"2020/03/12/Git教程/","link":"","permalink":"http://yoursite.com/2020/03/12/Git%E6%95%99%E7%A8%8B/","excerpt":"Git教程","text":"Git教程 Git介绍 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 完整命令手册地址：http://git-scm.com/docs PDF 版命令手册：github-git-cheat-sheet.pdf Git安装教程：菜鸟 Git 与 SVN 区别 git是分布式的，svn是集中式的。 Git 把内容按元数据方式存储，而 SVN 是按文件 Git 分支和 SVN 的分支不同 Git 没有一个全局的版本号，而 SVN 有 Git 的内容完整性要优于 SVN Git基本过程基本提交 git init:仓库初始化 git add . :把更新的内容提交到 git commit -m “提示信息” 下载 git clone 地址 查看状态 git status:查看状态 git diff 执行 git diff 来查看执行 git status 的结果的详细信息 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别 git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。 git reset HEAD git reset HEAD 文件名： 命令用于取消已缓存的内容。 git rm 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。 分支管理 创建分支：git branch 分支名字 切换分支：git checkout 分支名字 合并分支：git merge 子分支的名字 列出分支：git branch 删除分支：git branch -d 分支名字 合并冲突：手动解决 查看提交历史 git log:查看历史提交记录 git log –oneline：历史记录一行显示 标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 1$ git tag -a v1.0 远程仓库 git remote add origin 地址 git push -u origin master 下次提交直接Git push 待续。。。","categories":[],"tags":[]}]}